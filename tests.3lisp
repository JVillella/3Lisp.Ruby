;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                   ;;;
;;;                   ;;;
;;; 3LispR Test Cases ;;;
;;;                   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;
;;;
;;; Basics 
;;;


;;; Pairs

(pcons 'a 'b)       ; => '(A . B)
(pcons '+ '[2 3])   ; => '(+ 2 3)
(pcons 2 3)         ; Error

(car '(a . b))      ; => 'A
(car '(1 . $t))     ; => '1
(car '(+ 2 3))      ; => '+
(car '+)            ; Error

(cdr '(a . b))      ; => 'B
(cdr '(1 . $t))     ; => '$T
(cdr '(+ 2 3))      ; => '[2 3]
(cdr '(acons))      ; => '[]
(cdr '1)            ; Error

(xcons '+ '2 '3)    ; => '(+ 2 3)
(xcons 'acons)      ; => '(ACONS)
(xcons 1 2 3)       ; Error

;;; Rails and Sequences

(rcons '1 '2 '3)          ; => '[1 2 3]
(rcons 'a (pcons 'b 'c))  ; => '[A (B . C)]
(rcons)                   ; => '[]
(= (rcons) (rcons))       ; => $F
(= ↓(rcons) ↓(rcons))     ; => $T
(rcons 1 2 3)             ; Error

(scons 1 2 3)               ; => [1 2 3]
(scons '1 '2 '3)            ; => ['1 '2 '3]
(scons 'a (+ 2 2))          ; => ['A 4]
['a (+ 2 2)]                ; => ['A 4]
(scons)                     ; => []
(= (scons) (scons))          ; => $T
(= ↑(scons) ↑(scons))       ; => $F
(let [[x [1 2]]]
  (= x (scons . x)))        ; => $T
(let [[x [1 2]]]
  (= ↑x ↑(scons . x)))      ; =>$F

(prep 10 [20 30])           ; => [10 20 30]
(prep 'a '[b c])            ; => '[A B C]
(prep [$T] [$F])            ; => [[$T] $F]
(prep '10 [20 30])          ; => ['10 20 30]
(prep 10 '[20 30])          ; Error
(prep 1 2)                  ; Error

(length '[a b c])           ; => 3
(length (scons))            ; => 0
(length 3)                  ; Error

(NTH 1 [(+ 5 5) 20 30])     ; => 10 
(NTH 2 ['10 '2O '30])       ; => '20
(NTH 3 '[10 20 30])         ; => '30
(NTH 2 [10])                ; Error
(NTH '2 [10 20 30])         ; Error
(NTH 1 10)                  ; Error

(tail 2 [10 20 30 40])            ; => [30 40]
(tail 1 (cdr '(rcons 'a 'b 'c)))  ; => '['B 'C]
(let [[x '[a b]]] 
  (= x (tail 0 x)))               ; => $T
(letseq [[x [2 3]]
         [y (prep 1 x)]]
  (= ↑x ↑(tail 1 y)))             ; => $T
(tail 1 [1])                      ; => []
(tail 3 [1 2])                    ; Error
(tail $F [1 2])                   ; Error

(empty [])                  ; => $T
(empty '[])                 ; => $T
(empty '[a b c])            ; => $F
(empty (scons))             ; => $T
(empty (rcons))             ; => $T
(let [[x (rcons '1)]]
  (block (replace (tail 1 x) x)
         (empty x)))        ; => $F
(empty '(a. b))             ; Error

(unit '[a])                 ; => $T
(double (rest [10 20 30]))  ; => $T
(unit 1)                    ; Error

(foot [1 2 3])              ; => []
(= foot [1 2 3] [])         ; $T
(= (foot '[1 2 3]) '[])     ; $F
(LET [[X (SCONS 10 20)]] 
  (BLOCK 
    (REPLACE (FOOT ↑X) '[30 40])
    X))                     ; => [10 20 30 40]

(rest [ 1 2 3])             ; => [2 3]
(rest 1)                    ; Error

(3rd [10 20 30 40])         ; => 30
(1st (prep 'a '[b c]))      ; => 'A
(2nd [1])                   ; Error

(member 1 [2 3 4])          ; => $F
(member 3 [1 1 2 (+ 1 2)])  ; => $T
(member '2 '[1 2 3])        ; => $T
(member 2 ['1 '2 '3])       ; => $F
(member '[] '[[a] [] [b]])  ; => $F
(member [] [[1] [] [2]])    ; => $T
(member 1 2)                ; Error
(member * [+ - * /])        ; Error

(vector-constructor '[])    ; => {Closure: SIMPLE  args RCONS}
((vector-constructor '[]))  ; => '[]
(vector-constructor 10)     ; => {Closure: SIMPLE  args SCONS}
((vector-constructor 100))  ; => []
((vector-constructor ↑↑1))  ; => '[]

(map 1+ [2 3 4])            ; => [3 4 5]
(map * [1 2 3] [1 2 3])     ; => [1 4 9]
(map EF [$T $F] [1 2] [3 4]); => [1 4]
(map car [])                ; => []
(map up '[1 A $T])          ; => '['1 'A '$T]
(map 1+ [1 2 3] [4 5 6])    ; Error
(map 1 [1 2 3])             ; Error
(map 1+ 100)                ; Error

(COPY-VECTOR '[A B C])        ; '[A B C]
(COPY-VECTOR	[])             ; []
(LET [[Y [1 2 3]]]
  [(= Y (COPY-VECTOR Y))
   (= ↑Y ↑(COPY-VECTOR Y))])  ; => [$T $F]

(CONCATENATE '[A] '[B C])     ; => '[A B C]
(LET [[X (RCONS)]]
  (BLOCK
    (CONCATENATE X '[NEW TAIL]) 
    X))                       ; => '[NEW TAIL]
(LET [[X '[1 2 3]] [Y '[4 5]]]
  (BLOCK 
    (CONCATENATE X Y) 
    [X Y]))                   ; => ['[1 2 3 4 5] '[4 5]]

(APPEND [1 2 3] [4 5 6])      ; => [1 2 3 4 5 6]
(APPEND '[] '[A B C])         ; => '[A B C]
(LET [[X '[M N]]]
  (APPEND X X))               ; => '[M N M N]
(LETSEQ	[[X	'[M	N]]       
         [Y (APPEND X X)]]
  (= X (TAIL 2 Y)))           ; => $T
(LET [[X [1 2]] [Y [3 4]]]
  (BLOCK 
    (APPEND X Y)
    X))                       ; => [1 2]
(APPEND 1 [2 3])              ; Error

(APPEND* [1 2 3] [4 5 6] [7 8 9])   ; => [1 2 3 4 5 6 7 8 9]
(APPEND* '[A B C])                  ; => '[A B C]
(LET [[X '[G 0]]] 
  (APPEND* X X X))                  ; => '[G O G O G O]

(REVERSE [])                        ; => []
(REVERSE [1 2 3])                   ; => [3 2 1]
(REVERSE '[[A B] [C D]])            ; => '[[C D] [A B]]
(LET [[X [10]]] 
  (= X (REVERSE X)))                ; => $T
(LET [[X [10]]]
  (= ↑X ↑(REVERSE	X)))              ; => $F
(LET [[Y '[A]]] 
  (= Y (REVERSE Y)))                ; => $F
  
(index 3 [2 3 6 1])           ; => 2
(index 'B ['A 'B 'C])         ; => 2
(index [10] [1 $T [10]])      ; => 3
(index '+ [])                 ; => 0

(set s [])
(push 1 s)
(push 2 s)
s                             ; => [2 1]

(block
  (set s [])
  (push 1 s)
  (push 2 s))
s                             ; => [2 1]
(pop s)                       ; => 2
s                             ; => [1]

(ccons 'x '[] 'y 'z)              ; => '{Closure: X [] Y Z}
(ccons 'simple ↑global '[x] 'x)   ; => '{Closure: SiMPLE #<Environment:#####> [x] x}
(↓(ccons 'simple ↑global '[x] '(+ x 1)) 10) ; => 11

(procedure-type (ccons 'x '[] 'y 'z))   ; => 'x
(procedure-type ↑+)                     ; => 'SIMPLE
(procedure-type ↑if)                    ; => 'REFLECT
(procedure-type IF)                     ; Error

(environment-designator (ccons 'x ↑(econs) 'y 'z))  ; => '#<Environment:#####>
(environment-designator +)              ; Error

; ENVIRONMENT is the charactersitic function of the type Environment
; (environment-of (ccons 'x ↑(econs) 'y 'z))  ; => #<Environment:#####>
; (environment-of +)              ; Error

(pattern (ccons 'x ↑(econs) 'y 'z))           ; => 'Y
(pattern ↑(lambda simple [a b] (pcons b a)))  ; => '[A B]
(pattern ↑normalise)                          ; => '[EXP ENV CONT]
(pattern +)                                   ; Error

(body (ccons 'x ↑(econs) 'y 'z))           ; => 'Z
(body ↑(lambda simple [a b] (pcons b a)))  ; => '(PCONS A B)
(body ↑rest)                               ; => '(TAIL 1 VEC)
(body +)                                   ; Error

(reflective ↑+)                           ; => $F
(reflective ↑if)                          ; => $T
(reflective ↑let)                         ; => $T
(reflective (ccons 'x ↑(econs) 'y 'z))    ; => $F

(de-reflect (ccons 'x ↑(econs) 'y 'z))    ; => '{Closure: SIMPLE #<Environment:#####> Y Z}
(de-reflect ↑IF)                          ; => '{Closure: SIMPLE #<Environment:#####> [[PREMISE C1 C2] ENV CONT] (NORMALISE ...)}

(reflectify ↓(ccons 'x ↑(econs) 'y 'z))   ; => {Closure: REFLECT #<Environment:#####> Y Z}
(reflectify normalise)                    ; => {Closure: REFLECT #<Environment:#####> [EXP ENV CONT] (COND ...)}

;;; Atoms

(acons)               ; => '3LispAtom######
(= (acons) (acons))    ; => $F 

;;; Typing

(type 1)              ; => 'NUMBER
(type '1)             ; => 'NUMERAL
(type $F)             ; => 'TRUTH-VALUE
(type $T)             ; => 'TRUTH-VALUE
(type '$F)            ; => 'BOOLEAN
(type '$T)            ; => 'BOOLEAN
(type [1 2 3])        ; => 'SEQUENCE
(type '[1 2 3])       ; => 'RAIL
(type '['a 'b 'c])    ; => 'RAIL
(type +)              ; => 'FUNCTION
(type '+)             ; => 'ATOM
(type ↑+)             ; => 'CLOSURE
(type 'abc)           ; => 'ATOM
(type ''abc)          ; => 'HANDLE
(type '(a . b))       ; => 'PAIR
(type lambda)         ; => 'FUNCTION
(type (lambda simple [x] (+ x 1)))  ; => 'FUNCTION

(atom 'a)             ; => $T
(pair '(1st '[a b]))  ; => $T
(function +)          ; => $T
(closure '+)          ; => $F

(vector [1 2 3])      ; => $T
(vector '[a b])       ; => $T
(vector '(1 2 3))     ; => $F

(external 123)        ; => $T
(internal (+ 2 2))    ; => $F
(external +)          ; => $T
(internal '+)         ; => $T
(internal ↑+)         ; => $T

;;; Identity

(= 3 (+ 1 2))             ; => $T
(= 5 '5)                  ; => $F
(= '5 '5)                 ; => $T
(= $F $F $F $F)           ; => $T
(= [10 20] [10 20])       ; => $T
(= '[10 20] '[10 20])     ; => $F
(= ['10 '20] '[10 20])    ; => $F
(= '[10 20] ['10 '20])    ; => $F
(= car 3)                 ; => $F
(= [2 +] [3 +])           ; => $F
(= [+ 2] [+ 3])           ; => $F
(= + 1 +)                 ; => $F
(= + + 1)                 ; => $F
(= car cdr)               ; => Error
(= / (lambda simple [n1 n2] (/ n1 n2))) ; => Error

(isomorphic '5 '5)                  ; => $T
(isomorphic '[10 20] '[10 20])      ; => $T
(isomorphic '[10 20] ['10 '20])     ; => $F
(isomorphic ↑car ↑cdr)              ; => $F
(isomorphic '(a . b) '(a . b))      ; => $T
(isomorphic ''[x] ''[x])            ; => $T
(isomorphic ↑(lambda simple [x] x)
            ↑(lambda simple [x] x)) ; => $T

;;; Arithmetic Operations

(* 2 2 2 2)     ; => 16
(+ 1 3 5)       ; => 9
(+ 3)           ; => 3
(* 3)           ; => 3
(+)             ; => 0
(+ '1 '2)       ; Error

(- 100 2)       ; => 98
(- 3)           ; => -3
(- 10 20)       ; => -10
(- 9 1 3 5)     ; => 0
(- 9 (+ 1 3 5)) ; => 0
(-3)            ; Error
(- 0 $T)        ; Error

(/ 10 3)        ; => 3
(/ -10 3)       ; => -4  ; this follows Ruby!
(/ 10 -3)       ; => -4  ; tihs follows Ruby!
(/ -10 -3)      ; => 3
(/ 100 0)       ; Error

(remainder 10 3)    ; => 1
(remainder 10 -3)   ; => -2 ; this follows Ruby's modulo !
(remainder -10 -3)  ; => -1
(remainder -10 3)   ; => 2  ; this follows Ruby's modulo !
(remainder 10 0)    ; => Error

(1+ 20)             ; => 21
(map 1- [2 3 4])    ; => [1 2 3]

(< 2 3)             ; => $T
(>= 5 4 4 2 -1 -7)  ; => $T
(> 100 1000)        ; => $F
(<= 99 1 '1)        ; Error

(abs 100)           ; => 100
(abs -100)          ; => 100
(abs 0)             ; => 0
(abs '1)            ; Error

(min 3 1 4)         ; => 1
(min 0 1 -7)        ; => -7
(max 4)             ; => 4

(odd 100)           ; => $F
(even 100)          ; => $T
(odd -1)            ; => $T

(zero 1)            ; => $F
(negative -1)       ; => $T
(positive 0)        ; => $F
(non-negative 0)    ; => $T

(** 2 10)           ; => 1024
(** 10 0)           ; => 1
(** -5 3)           ; => -125

;;; Procedure Definition and Variable Binding

(define square (lambda simple [n] (* n n)))
(square 19)         ; => 361
(define factorial
  (lambda simple [n]
    (if (= n 0) 1 (* n (factorial (1- n))))))
(factorial 5)       ; => 120

(set factorial
  (y-operator
    (lambda simple [self]
      (lambda simple [n]
        (if (= n 0) 1 (* n (self (1- n))))))))
(factorial 6)       ; => 720

(set even&odd
  (y*-operator
    (lambda simple [even odd]
      (lambda simple [n]
        (if (= n 0) $t (odd (1- n)))))
    (lambda simple [even odd]
      (lambda simple [n]
        (if (= n 0) $f (even (1- n)))))))
((1st even&odd) 2)  ; => $T
((2nd even&odd) 2)  ; => $F

(lambda simple [a b] (* a b))                 ; => {Closure: SIMPLE #<Environment:#######> [A B] (* A B)}
((lambda simple [n] (+ n n)) 4)               ; => 8
((lambda reflect [args env cont] args) . xxx) ; => 'XXX at level++ prompt

(simple ↑(bind 'x '1 (econs)) '[] 'x)         ; => {Closure: SIMPLE #<Environment:#######> [] X}
((simple ↑(bind 'x '1 (econs)) '[] 'x))       ; => 1
((simple ↑global '[x] '(+ x 2)) 99)           ; => 101
((simple ↑(econs) '[x] '(acons)) 99)          ; Error   ; Something weird happens here!!!

(set reflect-test
  (lambda reflect [args env cont]
    (block (set stash args) (cont ''ok))))    ; This is the manual version, which is wrong
(reflect-test + (+ 2 2))
stash                                         ; Error
(reflect-test . +)
stash                                         ; Error

(set reflect-test
  (lambda reflect [args env cont]
    (block (rebind 'stash ↑args env) (cont ''ok))))    ; This is what I believe to be the correct version.
(reflect-test + (+ 2 2))
stash                                         ; => '[+ (+ 2 2)]
(reflect-test . +)
stash                                         ; => '+

(set reflect!-test
  (lambda reflect! [args env cont]
    (block (rebind 'stash ↑args env) (cont ''ok))))    ; This is what I believe to be the correct version.
(reflect!-test + (+ 2 2))
stash                                         ; => '[{Closure: SIMPLE  numbers +} 4]
(reflect!-test . +)
stash                                         ; => '{Closure: SIMPLE  numbers +}

(set macro-test
  (lambda macro [arg]
    (block (print ↑arg) arg)))    ; This is what I believe to be the correct version.
(macro-test (+ 2 2))              ; => 4 ; printing '(+ 2 2)
(macro-test . [+])                ; => {Closure: SIMPLE  numbers +}; printing '+

; rebind test
(let [[env (bind 'x '1 (bind 'y '2 (econs)))]]
  (block (rebind 'y ↑(+ 2 3) env)
         (rebind 'z '$T env)
         (map (lambda simple [a] (binding a env)) (bound-atoms env))))  ; => ['1 '$T '5]

(set x (+ 2 2))
x                 ; => 4
(set x (+ x x))
x                 ; => 8

(set x 'y)
(setref x (* 2 2))  ; I found myself having to use "↓var!" in the definition of SETREF
y                   ; => 4


(binding 'y (bind 'x 1 (bind 'y '2 (bind 'z '3 (econs)))))  ; => '2
(binding 'normalise global)                                 ; => {Closure: SIMPLE ...}
(let [[x (+ 1 2)]]
  ((lambda reflect [args env cont]
    (cont (binding 'x env)))))                              ; => 3


(binding 'x (bind 'x '2 (econs)))         ; => '2
(binding 'x (bind '[x] '[2] (econs)))     ; => '2
(binding 'x (bind '[x] ''[2] (econs)))    ; => ''2      ; I don't understand this one!!!
(binding 'z (bind '[x z] '[2 3] (econs))) ; => '3
(binding 'x (bind '[x y] '[[2] 3] (econs)))     ; => '[2]
(binding 'z (bind '[x [z]] '[2 [3]] (econs)))   ; => '3
(bind '[x] '2 (econs))                    ; Error
(bind '[x] '''[2] (econs))                ; Error
(bind '(a . b) '(1 . 2) (econs))          ; Error

(let [[x 3] [y 4]] (+ x y))               ; => 7
(let [[[a b] (rest [1 2 3])]] (+ a b))    ; => 5
(let [[x 3]]
  (let [[x 4] [y x]] (+ x y)))            ; => 7

(let [[x 3]]
  (letseq [[x 4] [y x]] (+ x y)))         ; => 8

(letrec [[even (lambda simple [n]
                  (if (= n 0) $T (odd (1- n))))]
          [odd (lambda simple [n]
                 (if (= n 0) $F (even (1- n))))]]
  (scons (even 2) (odd 2)))               ; => [$T $F]


;;; Control

(if (= 1 1) 'a 'b)        ; => 'A
(if (= 1 2) 'a  'b)       ; => 'B
(ef (= 1 2)
    (print "Hello")
    (print "Good-bye"))
(if (= 1 2)
    (print "Hello")
    (print "Good-bye"))
(ef [] 'a 'b)             ; Error

(cond 
  [(= 1 2) 10]
  [(= 1 3) 20]
  [(= 1 1) 30]
  [$T 40])                ; => 30

(cond
  [(= 1 2) (print "10")]
  [(= 1 3) (print "20")]
  [(= 1 1) (print "30")]
  [$T      (print "40")]) ; => 'OK

(block
  (print "2 ")
  (print "+ ")
  (print "2 ")
  (terpri)
  'done)                  ; => 'DONE; displaying "2 + 2 "

(catch (+ 2 2))           ; => 4
(catch (+ 2 (throw 3)))   ; => 3
(catch 
  (block 
    (throw (+ 3 3))
    100))                 ; => 6

(catch
  (block 
    (print "-2 ")
    (print "-1 ")
    (throw 'blast-off)
    (print "1 ")
    (print "2 ")))        ; => 'BLAST-OFF ; displaying "-2 -1"

(catch
  (+ (catch (* 5 3))
     (throw (* 6 (throw 4)))))  ; => 4

(throw (+ 2 2))           ; => '4 ; up one level

; delay & force
(set x (delay (* y y)))
(set y 7)
(force x)                 ; => 49
(set y 9)
(force x)                 ; => 81
(define new-if
  (lambda macro [p c1 c2]
    `(force (ef ,p (delay ,c1) (delay ,c2)))))
(new-if (= (+ 2 2) 4)
        (print "yes")
        (print "no"))     ; => OK; printing "YES"

(set x (delay (print greeting)))
(set greeting "Hi there")
(force x) ; => 'OK; printing "Hi there"
(set Greeting "Good-bye")
(force x) ; => 'OK; printing "Good-bye"

; selectq & select

(define activity
  (lambda simple [day]
    (selectq day
      [sunday 'sleep]
      [[monday tuesday] 'work]
      [$T 'ruminate])))
(activity 'sunday)              ; => 'SLEEP
(activity 'tuesday)             ; => 'WORK
(activity 'wednesday)           ; => 'RUMINATE

(define activity-2
  (lambda simple [day]
    (select day
      ['sunday 'sleep]
      [['monday 'tuesday] 'work]
      [$T 'ruminate])))
(activity-2 'sunday)              ; => 'SLEEP
(activity-2 'tuesday)             ; => 'WORK
(activity-2 'wednesday)           ; => 'RUMINATE


; do

(define new-reverse
  (lambda simple [vec]
    (do [[v vec (rest v)] [r ((vector-constructor vec)) (prep (1st v) r)]]
      [[(empty v) r]])))
      
(new-reverse [1 2 3])         ; => [3 2 1]
(new-reverse '[1 '[2] [3]])   ; => '[[3] '[2] 1]

;;; True Value Operations

(not $F)          ; => $T
(not (even 102))  ; => $F
(not 1)           ; Error

(and (= 1 1) (= 1 2))               ; => $F
(or (= 1 0) (= 1 2) (= 1 1))        ; => $T
(and)                               ; => $T
(or)                                ; => $F
(let [[x 3]]
  (block
    (and (= 1 2)
         (block (set x 4) $T))
    x))                             ; => 3


;;; Structural Side Effects

;;; REPLACE

(let [[x '(+ 2 3)]]
  (block (replace (cdr x) '[20 30])
         x))                        ; => '(+ 20 30)

(let [[x '(+ 2 3)]]
  (block (replace x '(* 2 3))
         x))                        ; => '(* 2 3) 

(let [[x '[]]]
  (block (replace x '[new tail])
         x))                        ; => '[NEW TAIL]

; test case for replacing closure
(define add
  (lambda simple [x y]
    (+ x y)))
(define inc
  (lambda simple [x] 
    (add x 1)))
(inc 99)                                ; => 100; printing nothing
(replace ↑add 
         ↑(lambda simple [x y] 
            (block 
              (print "adding up ") 
              (print ↑x) 
              (print "and ") 
              (print ↑y) 
              (terpri) 
              (+ x y))))
(inc 99)                                ; => 100; printing "adding up 99 and 1"

         
; test cases for RPLACA, RPLACD
(set x '(a . b))
(set y x)
(rplaca x 'c)
x                                   ; => '(C . B)
y                                   ; => '(C . B)
(rplacd y 'd)
x                                   ; => '(C . D)
y                                   ; => '(C . D)

; test cases for RPLACN
(set x '[one two three])
(set y (rest x))
(rplacn 2 x '**)
x                                   ; => '[ONE ** THREE]
y                                   ; => '[** THREE]

; test cases for RPLACT
(set x '[one two three])
(set y (rest x))
(set z (rest y))
(rplact 1 x '[end])
x                                   ; => '[ONE END]
y                                   ; => '[END]
z                                   ; => '[THREE]


; atom replacement not supported, because absorbed to Ruby's symbol ...
; thus the following examples won't work

(let [[x '(+ 2 3)]]
  (block (replace (car x) '*)
         x))

(let [[x '[a1 a2]]]
  (block (replace 'a1 'a2)
         x))


;;; Level Crossing Operations

↑5              ; => '5
↑(+ 2 3)        ; => '5
↑(lambda simple [x] x)      ; => '{Closure: SIMPLE #<Environemnt:#####> [x] x}
['(= 2 3) ↑(= 2 3)]         ; => ['(= 2 3) '$F]
(let [[x [2 3]]]
  (= x [2 3]))              ; => $T
(let [[x [2 3]]]
  (= ↑x ↑[2 3]))            ; => $F

↓'4                   ; => 4
↓(NTH 2 '[10 20 30])  ; => 20
↓↑$T                  ; => $T
↓3                    ; Error
↓'X                   ; Error

(referent '1 global)                ; => 1
(referent 'x (bind 'x '1 (econs)))  ; => 1    
(referent ''(+ 2 2) (econs))        ; => '(+ 2 2)
(referent (pcons '+ '[2 2]) global) ; => 4


;;; System Utilities

(version)             ; => "3Lisp version R00, April 15, 2011"


;;; Other General Utilities

(id 3)                ; => 3
(id (+ 2 2))          ; => 4
(id '(+ 2 3))         ; => '(+ 2 3)
(id id)               ; => {Closure: SIMPLE [X] X}

(id* 3)                   ; => [3]
(id* (+ 2 2) (type '1))   ; => [4 'NUMERAL]
(id* '(+ 2 3))            ; => ['(+ 2 3)]
(id* . global)            ; => #<Environment:#####>
(id* . (+ 2 2))           ; => 4

((macro-expander delay)
  '[(foo x)])             ; => '(lambda simple [] (foo x))
((macro-expander let)
  '[[x 1]] '(+ x 2))      ; => '((lambda simple [x] (+ x 2)) 1)

(quote 2)                 ; => '2
'2                        ; => '2
(quote (+ 2 2))           ; => '(+ 2 2)
'(+ 2 2)                  ; => '(+ 2 2)
(normalise 'a (econs) quote)    ; => '(BINDING EXP ENV)
(map quote [1 2])               ; => ['(1st (2nd args)) '(1st (2nd args))]

(normal '3)               ; => $T
(normal '(+ 2 3))         ; => $F
(normal ↑(+ 2 3))         ; => $T
(normal '[1 2 3])         ; => $T
(normal '[1 2 A])         ; => $F
(normal 'A)               ; => $F
(normal ''A)              ; => $T

(normal-rail '[])           ; => $T
(normal-rail '[1 $T "a"])   ; => $T
(normal-rail '[1 2 A])      ; => $F

(primitive ↑+)              ; => $T
(primitive ↑normalise)      ; => $F
(primitive ↑if)             ; => $F

(member ↑ef primitive-closures)  ; => $T
(member ↑if primitive-closures)  ; => $F

; there are no cond-helper and block-helper

(and-helper '[(= 2 2) (= 3 3)] global id)     ; => '$T
(or-helper '[(= 2 2) (= 3 4)] global id)      ; => '$T

;;; Processor

(normalise '1 [] id)                        ; => '1
(normalise 'x (bind 'x '1 (econs)) id)      ; => '1
(normalise '(+ 2 2) global id)              ; => '4
(normalise '+ global quote)                 ; => '(BINDING EXP ENV)
(normalise '$T global quote)                ; => 'EXP

(reduce '+ '[2 2] global id)                ; => '4
(reduce 'if '[$T 1 2] global id)            ; => '1
(reduce '+ '[2 2] global
  (lambda macro [x] ↑x))                    ; => '↑(↓proc! . ↓args!)

(normalise-rail '[1] [] id)                       ; => '[1]
(normalise-rail '[x x] (bind 'x '1 (econs)) ID)   ; => '[1 1]
(normalise-rail '[(+ 2 2)] global id)             ; => '[4]
(normalise-rail '[+] global
  (lambda macro [x] ↑x))                          ; => '(PREP FIRST! REST!)
(normalise-rail '[] global
  (lambda macro [x] ↑x))                          ; => '(RCONS)


(binding 'x (bind '[x] '[2] global))              ; => '2
(binding 'x (bind '[x] ''[2] global))             ; => '


;;; Booleans

(and $T $T $F)
(and (= '[] '[]))
(and)
(and . (tail 1 [$F $T $T]))

(or $F $F $T)
(or (= '[] '[]))
(or)
(or . (tail 1 [$T $F $F]))

;;; Equality (actually referential identity)

(= [1 2 3] [1 2 3])
(= '[1 2 3] '[1 2 3])
(= [1 2 3] '[1 2 3])

;;; LET

(let [[x 10][y (empty [])]]
	(if y
		(* x x)
		(+ x x)))
		
(letseq [[a 1] 
         [b (+ a 1)] 
         [c (* b 2)]]
  [a b c])

(letrec [[a 1] 
         [b (+ a 1)] 
         [c (* b 2)]]
  [a b c])

(letrec [[even (lambda simple [n] (if (zero n) $T (odd  (1- n))))]
         [odd  (lambda simple [n] (if (zero n) $F (even (1- n))))]]
  [(even 10) (even 11) (odd 10) (odd 11)])


;;; SELECT

(select 1 [1 2] [2 3] [3 4])
(select 3 [1 2] [2 3] [3 4])


;;; DO 

(define new-reverse
  (lambda simple [vec]
    (do [[v vec (rest v)]
         [r ((vector-constructor vec)) (prep (1st v) r)]]
        [[(empty v) r]])))

(new-reverse [1 2 3])        

;;; binding

(rebind 'a '10 global)
(binding 'a global)

;;; ↑↓

; ↓ tests from diss.p483
↓'[1 2 3 4]

↓(prep '1 (rcons '2 '3 '4))

↓↓''''A

(+ . ↓(rcons '1 '2))

(let [[x '$F]] [(type x) (type ↓x)])


; these last four ain't correct

↓'(pcons 'a 'b)
(↓(pcons 'pcons (rcons ''a ''b)))
↓(pcons 'a 'b)
↓(+ 2 3)

;;; Backquote

(rebind 'b ''2 global)
(rebind 'c '''3 global)

`1
`(a . b)
`(,b . a)
`[a b]
`[a ,b c]
`[[a b][,c d]]
``[a ,b ,,c]



;;;
;;; Basics 
;;;
;;;;;;;;;;;;;


(set factorial
  (y-operator
    (lambda simple [self]
      (lambda simple [n]
        (if (= n 0) 1 (* n (self (1- n))))))))

(define DEFEIN
  (lambda macro [label form]
    `(block (set ,label (y-OPERATOR (lambda simple [,label] ,form)))
            ,↑label)))

(defein fact (lambda simple [n]
  (if (zero n)
      1
      (* n (fact (1- n))))))

(fact 10)

;;;;;;;;;;;;;
;;;
;;; Lambda
;;;

((lambda simple [x] x) 100)

(define a (lambda simple [b] (b 1 2)))
(a +)

; lambda tests from BCS diss.pp437-443
; should => 18
((lambda simple [f]
  (f (f 3 4) (f 5 6)))
+)

; should => [30]
((lambda simple [g1 g2]
  (g1 (= (nth 1 '[$T]) (nth 1 ['$T]))
      (g2 [10 20 30])
      (g2 '[10 20 30])))
if
(lambda simple [r] (tail 2 r)))

; should => 10
(((lambda simple [f]
    (f simple [y] (+ y y)))
  lambda)
5)

; should => 3
((lambda simple [fun]
  ((lambda simple [y]
    (fun y))
  2))
 ((lambda simple [y]
   (lambda simple [x] (+ x y)))
1))

; should => 7
((lambda simple [a](a 3 4)) (lambda simple [b c](+ b c)))

; tricky lambda testing lexical scopes
(define trouble
  (lambda simple [args]
    (let [[proc! (1st args)]]
      (cond
        [(= proc! 0)
           (let [[binding! (trouble (rest args))]]
             (+ (1st args) binding!))]
        [(= proc! 1) 2]))))
(trouble [0 1]) ; should => 2

; without using LET
(define trouble1
  (lambda simple [args]
    ((lambda simple [n]
       (if (= n 0)
           ((lambda simple [x]
              (+ (nth 1 args) x))
            (trouble1 (tail 1 args)))
           (if (= n 1)
               2
               10000)))
     (nth 1 args))))
(trouble1 [0 1]) ; should => 2

;;;
;;; Lambda
;;;
;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;
;;;
;;; Recursion
;;;

;;; simple recursion

(define factorial (lambda simple [x] (if (= x 0) 1 (* x (factorial (- x 1))))))
(factorial 0)
(factorial 100)

;;; mutual recursion

(define even
  (lambda simple [n]
    (if (= 0 n) 
        $T
        (odd (- n 1)))))

(define odd
  (lambda simple [n]
    (if (= 0 n)
        $F
        (even (- n 1)))))

(even 0)
(even 100)
(even 101)
(odd 0)
(odd 100)
(odd 101)

;;;
;;; Recursion
;;;
;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;
;;;
;;; Control flow
;;;

(block (terpri) (terpri) (terpri))

(ef (= 1 1) (+ 3 3) (* 3 3))

(cond
	[(= 1 2) 'ha]
	[(not (= (* 3 3) (/ 18 2))) (empty [])]
	[$T 'blah])

((if (even 3) + -) 4 5)
((nth 2 [+ if lambda]) $T 0 1)

;;;
;;; Control flow
;;;
;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;
;;;
;;; Reflection 
;;;

;;; Going meta

1
(normalise '1 global id)
(normalise '(normalise '1 global id) global id)
(normalise '(normalise '(normalise '1 global id) global id) global id)
(normalise '(normalise '(normalise '(normalise '1 global id) global id) global id) global id)
(normalise '(normalise '(normalise '(normalise '(normalise '1 global id) global id) global id) global id) global id)

;;; basic reflection tests 

; test case from Implementation paper

(define three (lambda reflect [[] env cont] (cont '3)))
(three)

(define quit (lambda reflect [args env cont] 'done))
(+ 2 (quit))
(read-normalise-print 1 global)
(read-normalise-print 2001 global)
(quit)
(quit)

; environment manipulation

((lambda reflect [[x] env cont] (normalise '(+ x 1) (bind 'x x env) cont)) 10)

;;; DEFINE can be defined

((lambda reflect [args env cont]
   (block (rebind 'b '10 env)
          (cont 'done))))
; b is now bound to 10

(define DEFINE-2
    (lambda reflect [[var def] env cont]
        (normalise def env
            (lambda simple [def!]
                (block (rebind var def! env)
                       (cont ↑var))))))
(define-2 100+
  (lambda simple [x]
    (+ 100 x)))
(100+ 1) ; should => 101

;;; SCHEME-CATCH

(define scheme-catch
  (lambda reflect [[tag body] catch-env catch-cont]
    (normalise body 
	  (bind tag ↑(lambda reflect [[answer] throw-env throw-cont]
	               (normalise answer throw-env catch-cont))
		    catch-env)
	  catch-cont)))

; should => 17
((lambda simple [x]
   (+ 2 (scheme-catch punt 
                      (* 3 (/ 4 (if (= x 1)
					                (punt 15)
									(- x 1))))))) 1)

;;; BREAK

(define BREAK 
  (lambda reflect [[arg] env cont]
    (block 
      (print arg) 
      (read-normalise-print 'debug
        (bind '[env cont return]
              [↑env ↑cont ↑(lambda reflect [[a2] e2 c2] (normalise a2 e2 cont))]
              env)))))

(define factorial-with-break-point 
  (lambda simple [x] 
    (if 
      (= x 0) 
      1 
      (break (* x (factorial-with-break-point (- x 1))))))) ; uses BREAK

; use "(return EXP)" to exit BREAK
(factorial-with-break-point 5)

;;; Reflective continuation vs. regular (simple) continuation

(define quote (lambda reflect [[a] e c] (c ↑a)))
(normalise '1 global id)
(normalise '1 global quote)
(normalise '+  global id)
(normalise '+ global quote)
(normalise '(+ 1 2) global id)
(normalise '(+ 1 2) global quote)
(normalise-rail '[] global id)
(normalise-rail '[] global quote)
(normalise-rail '[1] global id)
(normalise-rail '[1] global quote)

;;; More reflective continuation

(define alpha
  (lambda reflect [[alpha-arg] alpha-env alpha-cont] [alpha-arg alpha-env alpha-cont]))

(normalise '3 global alpha)
(normalise 'x global alpha)
(normalise '(+ 2 3) global alpha)
(normalise '[] global alpha)

; this is a mistaken one ...

((lambda simple [x y]  
   (normalise '[x x y y] global alpha))
3 4)

((lambda simple [x y]  ;; this is a correct one ...
   (normalise '[+ - * /] global alpha))
3 4)

(normalise-rail '[] global alpha)
(normalise '(lambda simple [a] (+ a a)) global alpha)

;;;
;;; Reflection
;;;
;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; A version of the RPP that normalises arguments right to left.
;;; From a discussion with Brian
;;;

;;; Brian's original code

(define normalise#
  (lambda simple [exp env cont]
    (cond [(normal exp) (cont exp)]
          [(atom exp) (cont (binding exp env))]
          [(rail exp) (normalise-rail# exp env cont)]
          [(pair exp) (reduce# (car exp) (cdr exp) env cont)])))

(define reduce#
  (lambda simple [proc args env cont]
    (normalise# proc env
      (lambda simple [proc!]
        (if (reflective proc!)
            (↓(de-reflect proc!) args env cont)
            (normalise# args env ; JL: changed "normalise" to "normalise#"
              (lambda simple [args!]
                (if (primitive proc!)
                    (cont ↑(↓proc! . ↓args!))
                    (normalise#
                       (body proc!)
                       (bind (pattern proc!) args! (environment-of proc!))
                       cont)))))))))


(define normalise-rail#
  (lambda simple [rail env cont]
     (if (empty rail)
         (cont rail)
         (normalise-rail# (rest rail) env
            (lambda simple [rest!]
               (normalise# (1st rail) env
                  (lambda simple [first!]
                     (cont (prep first! rest!)))))))))
                     
(define block#
  (lambda reflect [clauses env cont]
    (normalise-rail# clauses env 
      (lambda simple [clauses!]
        (cont (nth (length clauses!) clauses!))))))

;;; Simple test case for block#

(block# (+ 2 3) (print 'A) (* 2 3))

;;; Test cases. The first should print "AB" before returning '[5 6];
;;; the second should print "BA" but return the same result.

(normalise
   '[(block (+ 2 3) (print 'A) (+ 2 3))
     (block (* 2 3) (print 'B) (* 2 3))]
   global
   id)

(normalise#
   '[(block# (+ 2 3) (print 'A) (+ 2 3))
     (block# (* 2 3) (print 'B) (* 2 3))]
   global
   id)

;;; Note that the definitions of NORMALISE and NORMALISE# establish
;;; the order of argument normalisation independent of how *they*
;;; are normalised.  Thus the following 4 cases print "AB", "BA",
;;; "AB", and "BA", respectively.  This shows that the 3Lisp RPP
;;; enforces left-to-right argument processing (rather than merely
;;; absorbing it from levels above).

;;; JL: add ' before the inner call to normalise... for the last 3 cases

(normalise
  '(normalise
     '[(block (print 'A) (+ 2 3))
       (block (print 'B) (* 2 3))]
     global
     id)
  global
  id)

(normalise
  '(normalise#
    '[(block# (print 'A) (+ 2 3))
      (block# (print 'B) (* 2 3))]
    global
    id)
  global
  id)

(normalise#
  '(normalise
    '[(block (print 'A) (+ 2 3))
      (block (print 'B) (* 2 3))]
    global
    id)
  global
  id)

(normalise#
  '(normalise#
    '[(block# (print 'A) (+ 2 3))
      (block# (print 'B) (* 2 3))]
    global
    id)
  global
  id)


;;; JL: The following test-cases, would test order of argument normalization directly

(normalise  '(+ (block  (print 'A) 2) (block  (print 'B) 3)) global id)
(normalise# '(+ (block# (print 'A) 2) (block# (print 'B) 3)) global id)

;;; JL: Test cases for interaction (or lack thereof) of normalise? and block? ...

(normalise  '(block   (print 'A) (print 'B) 2) global id)
(normalise# '(block#  (print 'A) (print 'B) 2) global id)
(normalise  '(block#  (print 'A) (print 'B) 2) global id)
(normalise# '(block   (print 'A) (print 'B) 2) global id)

;;; JL: Just FYI, block is defined as follows
;
;(define BLOCK
;  (lambda reflect [clauses env cont]
;    (if (unit clauses)
;		 (normalise (1st clauses) env cont)
;        (normalise (1st clauses) env
;          (lambda simple arg                      ; BLOCK continuation
;            (normalise (pcons 'block (rest clauses)) env cont)))) 

;;;
;;; A version of the RPP that normalises arguments right to left.
;;; From a discussion with Brian
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;





